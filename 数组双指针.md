# 二分搜索

[二分搜索](BinarySearch.md)

# 滑动窗口

[滑动窗口](滑动窗口.md)

# 其他题目

### 1. nSum问题

这类 `nSum` 问题就是给你输入一个数组 `nums` 和一个目标和 `target`，让你从 `nums` 选择 `n` 个数，使得这些数字之和为 `target`。

[1. TwoSum(返回index, 因此尽量不改变原数组)](https://leetcode.com/problems/two-sum/)

[15. 3Sum](https://leetcode.com/problems/3sum/)

[18. 4Sum](https://leetcode.com/problems/4sum/)

#### 1. TwoSum

##### a. 返回index, 因此尽量不改变原数组(非双指针)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (hashMap.containsKey(target-nums[i])) {
                return new int[] {i, hashMap.get(target-nums[i])};
            } else {
                hashMap.put(nums[i], i);
            }
        }
        return new int[]{0, 0};
    }
}
```

##### b. 返回值, 假设有且只有一对. 

排序+ 左右指针

```java
public int[] twoSum(int[] nums, int target) {
  Arrays.sort(nums);
  int lo = 0, hi = nums.length - 1;
  while (lo < hi) {
    int sum = nums[lo] + nums[hi];
    if (sum < target) {
      lo++;
    } else if (sum > target) {
      hi--;
    } else if (sum == target) {
      return new int[2]{nums[lo], nums[hi]};
    }
  }
  return ;
}
```

##### c. 返回值, nums有重复, 可能有多个元素之和为target, 都反悔且不能重复

1. 初始思路同上, 在sum == target 条件中将答案加入 -> 此时会有重复

2. 对双指针的while循环做出修改

   ```java
   while(lo < hi) {
     int sum = nums[lo] + nums[hi];
     int left = nums[lo], right = nums[hi];
     if (sum < target) lo++;
     else if (sum > target) hi--;
     else {
       res.push(new int[2]{left, right});
       while (lo < hi && nums[lo] == left) lo++;
       while (lo < hi && nums[hi] == right) hi--;
     }
   }
   ```

3. 前两个也可以做一点效率优化, 跳过相同元素

   ```java
   while(lo < hi) {
     int sum = nums[lo] + nums[hi];
     int left = nums[lo], right = nums[hi];
     if (sum < target) {
       while (lo < hi && nums[lo] == left) lo++;
     } else if (sum > target) {
       while (lo < hi && nums[hi] == right) hi--;
     } else {
       res.push(new int[2]{left, right});
       while (lo < hi && nums[lo] == left) lo++;
       while (lo < hi && nums[hi] == right) hi--;
     }
   }
   ```

​	这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 `O(N)`，而排序的时间复杂度是 `O(NlogN)`，所以这个函数的时间复杂度是 `O(NlogN)`。

 #### 15. 3Sum (nSum模版)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        // n 为3 从nums[0] 开始计算和为0的三元组
        return nSumTarget(nums, 3, 0, 0);
    }
    List<List<Integer>> nSumTarget(int[] nums, int n, int start, int target) {
        int length = nums.length;
        List<List<Integer>> res = new LinkedList<>();
        // 至少是2Sum
        if (n < 2 || length < n) return res;
        if (n == 2) {
            int lo = start, hi = length - 1;
            while (lo < hi) {
                int sum = nums[lo] + nums[hi];
                int left = nums[lo], right = nums[hi];
                if (sum < target) {
                    while (lo < hi && nums[lo] == left) lo++;
                } else if (sum > target) {
                    while (lo < hi && nums[hi] == right) hi--;
                } else {
                    LinkedList<Integer> solution = new LinkedList<>();
                    solution.add(left);
                    solution.add(right);
                    res.add(solution);
                    while (lo < hi && nums[lo] == left) lo++;
                    while (lo < hi && nums[hi] == right) hi--;                  
                }
            }
        } else {
            for (int i = start; i < length; i++) {
                List<List<Integer>> sub = nSumTarget(nums, n - 1, i + 1, target - nums[i]);
                for (List<Integer> arr : sub) {
                    arr.add(nums[i]);
                    res.add(arr);
                }
                while (i < length - 1 && nums[i] == nums[i+1]) i++;
            }
        }
        return res;
    }
}
```

#### 4Sum 的整型溢出问题



### 2. 高效解决接雨水
